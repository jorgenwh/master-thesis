\subsection{Implementing Our Own \textit{k}mer Counting Tool} \label{discussion:implementing_our_own_kmer_counting_tool}
%In section \ref{results:benchmarking} we showed that Gerbil's runtime was greater than that of GKAGE despite Gerbil only performing \textit{k}mer counting and GKAGE performing the full genotyping pipeline.
In section \ref{results:benchmarking} we showed that Gerbil spent more time performing just \textit{k}mer counting, even with GPU support, than GKAGE spent performing the full genotyping pipeline.
Our reason for implementing a new tool for \textit{k}mer counting on the GPU, and why our tool seemingly performed so much better than Gerbil, was because the problems solved by Gerbil and GKAGE's \textit{k}mer counting tool are inherently different.
Recall from section \ref{background:kmers_and_kmer_counting}, we defined \textit{full k}mer counting as the problem of counting the occurrence of every valid \textit{k}mer in a set of reads, and \textit{partial k}mer counting as the problem of only counting the occurrences of \textit{k}mers present in a predefined set of \textit{k}mers in a set of reads.
Unlike the \textit{k}mer counting tool we implemented for GKAGE, Gerbil solves the \textit{full k}mer counting problem - a significantly more processing and memory demanding task compared to \textit{partial k}mer counting.
While Gerbil could have been used in GKAGE for the \textit{k}mer counting portion, we would not only be counting the occurrences of superfluous \textit{k}mers, we would additionally be required to parse Gerbil's output for the wanted \textit{k}mer counts.
It was for this reason that we decided to implement a new \textit{k}mer counting tool targeted for our particular purpose.
